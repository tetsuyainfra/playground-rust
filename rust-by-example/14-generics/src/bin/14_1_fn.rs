// ジェネリック関数
// 型Tはその前に<T>があればジェネリック型になるというルールは関数でも同じ

// ジェネリック関数を使用する際、以下のような場合に型パラメータの明示が必要
// - 返り値がジェネリック型
// - コンパイラが型パラメータを推論するのに十分な情報がないとき

struct A; // Concrete type `A`.
          // 具象型`A`.
struct S(A); // Concrete type `S`.
             // 具象型`S`.
struct SGen<T>(T); // Generic type `SGen`.
                   // ジェネリック型`SGen`.

// 以下の関数は全て変数の所有権をとった後すぐにスコープを抜けて
// 変数をメモリ上から開放する。

// <T>が無いのでジェネリック関数ではない
fn reg_fn(_s: S) {}

// これはAという型を与えられた「SGen<A>という型の引数_s」を取る。
// 関数名の後に<A>という型パラメータでAがジェネリック型であることを明示していない
// ジェネリック関数ではない
fn gen_spec_t(_s: SGen<A>) {}

// 同様にこの関数もジェネリック関数ではない
fn gen_spec_i32(_s: SGen<i32>) {}

// これは関数名の直後に<T>が先行して定義されており、Tに対してジェネリックな関数
fn generic<T>(_s: SGen<T>) {}

fn main() {
  //使用例
  reg_fn(S(A));

  gen_spec_t(SGen(A));
  gen_spec_i32(SGen(6));

  // generic関数に対してchar型の型パラメータを明示して呼び出す
  generic::<char>(SGen('a'));

  // 型パラメータ char を暗黙的にgeneric関数に渡す
  generic(SGen('a'));
}

// なんとなくRust内部でのGeneric関数のテーブルがどうなってるかを感じた
// おそらく型パラメータで分岐して関数テーブルを持っているのだろう
