// Rustはメタプログラミングを可能にする、パワフルなマクロシステムを備えています。
// これまで見てきたように、マクロは!で終わることを除けば関数のように見えます。
// 関数と違うのは関数呼び出し(function call)を生成する代わりに、
// ソースコード中に展開され、周囲のプログラムとともにコンパイルされる点です。

// `say_hello`という名のシンプルなマクロ
macro_rules! say_hello {
    // `()`はマクロが引数をとらないことを示す。
    () => {
        // マクロは（訳注: プリコンパイルの段階で）このブロック内の内容に展開されます。
        println!("Hello!");
    };
}

fn main() {
    // この呼び出しは`println!("Hello");`に置き換えられます。
    say_hello!()
}

// なぜマクロが有能なのか

// 1. 繰り返しを避けられる。多くのケースで似たような機能が多くの場所で異なるタイプで必要とする。
//    多くの場合、マクロを書くことで便利な方法で繰り返しを避けることができる
// 2. ドメイン特化言語である。マクロを使ってあなたが特別な目的のために特別な記法を定義できる
// 3. 可変インターフェース。可変数の引数を取るインターフェースを定義したい場合があります。
//    println!など、フォーマット文字列に応じて、任意の数の引数を取ることができます！。
