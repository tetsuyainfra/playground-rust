// 所有権とムーブ
// 変数は保持する資源を解放する責任がある
// 資源は一度に一つの所有者しか持つことができない = 資源を二度以上解放できない（しない）
// すべての変数が資源を所有するとは限らない

// let x = y, foo(x) では資源の所有権(ownership)が移動する
// これをRustではMoveという

// 資源を移動するとそれまでの所有者を使用することはできなくなる
// これによってダブリングポインタの発生を防ぐ

fn destroy_box(c: Box<i32>) {
  println!("Destroying a box that contains {}", c);

  // ここでcは破棄される
}

fn main() {
  let x = 5u32;

  let y = x; // ここで xをyへCopyする

  println!("x is {}, and y is {}", x, y);

  let a = Box::new(5i32);

  // aをb Move する
  let b = a;
  // aの指すメモリ上の番地がbにコピーされるため
  // ヒープ上の同じ値を差すポインタになる
  // ただし所有者は b になる

  // エラー! `a`は所有権を持たないため、ヒープ上のデータにアクセスできない。
  // println!("a contains: {}", a); // Error

  // 所有者を関数に渡す
  destroy_box(b);

  // この時点でヒープメモリ上の資源は開放されているので、次の操作は解放
  // 解放済みメモリをデリファレンスすることになる。しかしそれはコンパイラが許さない。
  // println!("b contains: {}", b); // Error
}
