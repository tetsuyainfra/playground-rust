// 明示的アノテーション

// 借用チェッカーは参照がどれだけの間有効か決定するために明示的なアノテーションを理使用する
// ライフタイムが省略され無かった場合、Rustはライフタイムがどのようなものであるか
// 明示的なアノテーションを必要とする
// 例
// foo<'a> fooｈ'aというライフタイムパラメータを持つ

// ライフタイムの使用はジェネリクスを必要とします。
// この書き方は「fooのライフタイムは'aのそれを超えることはない。」ということを示しており、
// 型を明示した場合'a は &'a Tとなるということです。

// ライフタイムが複数ある場合も、同じような構文になります。
// foo<'a, 'b> // ジェネリック型fooは'aと'bというライフタイムパラメータを持つ

// i32はそれぞれ'a,'bというライフタイムを持つ、
// これらは最低でもprint_refs関数と同じとなる
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
  println!("x is {} and b is {}", x, y);
}

// 引数を取らないがライフパラメータ'aを持つ関数
fn failed_borrow<'a>() {
  let _x = 12;

  // 'a というライフタイムは関数と少なくとも同じ長さ
  // let y: &'a i32 = &_x; // Error
  // しかし`&_x`のライフタイムは`y`のそれよりも短いため、
  // 関数内で`'a`を使用して変数のライフタイムを指定しようとすると失敗する。
  // つまり、短いライフタイムを持つ参照をより長いものに強制的に代入することはできない。
}

fn main() {
  let (four, nine) = (4, 9);

  print_refs(&four, &nine);
  // 借用された変数の寿命は、借り手のそれよりも長くなくてはならない。
  // つまり、`four`、`nine`のライフタイムは`print_refs`のそれよりも
  // 長くなくてはならない。
  failed_borrow();
  // `failed_borrow`は関数のライフタイムよりも`'a`を長くさせるような
  // 参照を持たないが、それでも`'a`のほうが長くなる。なぜならそのような
  // 場合`'a`はデフォルトで`'static`になるからである。
}
